/*
 Copyright (C) Federico Zivolo 2019
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */
 (function(global, factory) {
    const globalObject = typeof window !== 'undefined' ? window : (typeof globalThis !== 'undefined' ? globalThis : global);
    if (typeof exports === 'object' && typeof module !== 'undefined') {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define(factory);
    } else {
        globalObject.Popper = factory();
    }
})(this, function() {
    'use strict';

    function isFunction(fn) {
        return fn && {}.toString.call(fn) === '[object Function]';
    }

    function getStyleComputedProperty(element, property) {
        if (element.nodeType !== 1) return [];
        const windowObj = element.ownerDocument.defaultView;
        const styles = windowObj.getComputedStyle(element, null);
        return property ? styles[property] : styles;
    }

    function getParentNode(element) {
        return element.nodeName === 'HTML' ? element : element.parentNode || element.host;
    }

    function getScrollParent(element) {
        if (!element) return document.body;
        const nodeName = element.nodeName;
        if (nodeName === 'HTML' || nodeName === 'BODY') {
            return element.ownerDocument.body;
        }
        const style = getStyleComputedProperty(element);
        const overflow = style.overflow;
        const overflowX = style.overflowX;
        const overflowY = style.overflowY;
        return /(auto|scroll|overlay)/.test(overflow + overflowY + overflowX) ? element : getScrollParent(getParentNode(element));
    }

    function getReferenceNode(reference) {
        return reference && reference.referenceNode ? reference.referenceNode : reference;
    }

    function isIE(version) {
        const ua = navigator.userAgent;
        if (version === 11) {
            return /Trident.*rv[ :]*11\./.test(ua);
        } else if (version === 10) {
            return ua.indexOf('MSIE 10') > -1;
        }
        return false;
    }

    function getOffsetParent(element) {
        if (!element) return document.documentElement;
        let offsetParent = element.offsetParent;
        while (offsetParent && getStyleComputedProperty(offsetParent, 'position') === 'static') {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || document.documentElement;
    }

    function getRoot(element) {
        return element.parentNode ? getRoot(element.parentNode) : element;
    }

    function findCommonOffsetParent(element1, element2) {
        if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) return document.documentElement;
        const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
        const start = order ? element1 : element2;
        const end = order ? element2 : element1;
        const range = document.createRange();
        range.setStart(start, 0);
        range.setEnd(end, 0);
        const commonAncestorContainer = range.commonAncestorContainer;
        if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
            return getOffsetParent(commonAncestorContainer);
        }
        const root = getRoot(element1);
        return root.host ? findCommonOffsetParent(root.host, element2) : findCommonOffsetParent(element1, getRoot(element2).host);
    }

    function getWindowScroll(element, side = 'top') {
        const ownerDocument = element.ownerDocument || element.document;
        const documentElement = ownerDocument.documentElement;
        return (side === 'top' ? ownerDocument.body.scrollTop : ownerDocument.body.scrollLeft) || (side === 'top' ? documentElement.scrollTop : documentElement.scrollLeft);
    }

    function getBoundingClientRect(element) {
        let rect;
        try {
            rect = element.getBoundingClientRect();
        } catch (error) {
            rect = {};
        }
        return {
            left: rect.left || 0,
            top: rect.top || 0,
            width: rect.width || 0,
            height: rect.height || 0,
            right: rect.right || 0,
            bottom: rect.bottom || 0
        };
    }

    function getComputedStyle(element) {
        const ownerDocument = element.ownerDocument || element.document;
        const windowObj = ownerDocument.defaultView;
        return windowObj.getComputedStyle(element);
    }

    function isFixed(element) {
        if (element === document.documentElement) return false;
        return getStyleComputedProperty(element, 'position') === 'fixed' || isFixed(getParentNode(element));
    }

    function getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {
        const html = element.ownerDocument.documentElement;
        const rect = getBoundingClientRect(element);
        const scrollTop = !excludeScroll ? getWindowScroll(html) : 0;
        const scrollLeft = !excludeScroll ? getWindowScroll(html, 'left') : 0;
        const width = Math.max(html.clientWidth, window.innerWidth || 0);
        const height = Math.max(html.clientHeight, window.innerHeight || 0);

        const offset = {
            top: scrollTop - rect.top,
            left: scrollLeft - rect.left,
            width: width,
            height: height
        };

        return Object.assign({}, offset, {
            bottom: offset.top + offset.height,
            right: offset.left + offset.width
        });
    }

    function getPopperOffsets(popper, referenceOffsets, placement) {
        placement = placement.split('-')[0];

        const popperRect = getBoundingClientRect(popper);
        const popperOffsets = {
            width: popperRect.width,
            height: popperRect.height
        };

        const isHorizontallyAligned = ['right', 'left'].indexOf(placement) !== -1;
        const mainSide = isHorizontallyAligned ? 'top' : 'left';
        const secondarySide = isHorizontallyAligned ? 'left' : 'top';
        const measurement = isHorizontallyAligned ? 'height' : 'width';
        const secondaryMeasurement = isHorizontallyAligned ? 'width' : 'height';

        popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

        if (placement === secondarySide) {
            popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
        } else {
            popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
        }

        return popperOffsets;
    }

    // Other utility functions and logic
    function getOppositePlacement(placement) {
        const oppositeMap = {
            left: 'right',
            right: 'left',
            bottom: 'top',
            top: 'bottom'
        };
        return placement.replace(/left|right|bottom|top/g, matched => oppositeMap[matched]);
    }

    // Other functions for managing popper...
    return {
        getPopperOffsets,
        getBoundingClientRect,
        getStyleComputedProperty
        // Add other exported methods here
    };
});

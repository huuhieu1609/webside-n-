/*! WOW wow.js - v1.3.0 - 2016-10-04
* https://wowjs.uk
* Copyright (c) 2016 Thomas Grainger; Licensed MIT */
(function(global, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['module', 'exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(module, exports);
    } else {
        const mod = { exports: {} };
        factory(mod, mod.exports);
        // Ensure the WOW object is assigned to the global scope, either window or globalThis
        (typeof globalThis !== 'undefined' ? globalThis : global).WOW = mod.exports;
    }
})(this, function(module, exports) {
    'use strict';

    class WOW {
        constructor(options = {}) {
            this.defaults = {
                boxClass: 'wow',
                animateClass: 'animated',
                offset: 0,
                mobile: true,
                live: true,
                callback: null,
                scrollContainer: null,
                resetAnimation: true
            };

            this.config = { ...this.defaults, ...options };
            this.animate = ('requestAnimationFrame' in window) ? fn => window.requestAnimationFrame(fn) : fn => fn();
            this.vendors = ['moz', 'webkit'];
            this.start = this.start.bind(this);
            this.resetAnimation = this.resetAnimation.bind(this);
            this.scrollHandler = this.scrollHandler.bind(this);
            this.scrollCallback = this.scrollCallback.bind(this);
            this.scrolled = true;
            this.animationNameCache = new WeakMap();
            this.wowEvent = this.createEvent(this.config.boxClass);

            if (this.config.scrollContainer) {
                this.config.scrollContainer = document.querySelector(this.config.scrollContainer);
            }
        }

        init() {
            this.element = window.document.documentElement;
            if (['interactive', 'complete'].includes(document.readyState)) {
                this.start();
            } else {
                this.addEvent(document, 'DOMContentLoaded', this.start);
            }
            this.finished = [];
        }

        start() {
            if (this.stopped) return;
            this.boxes = Array.from(this.element.querySelectorAll(`.${this.config.boxClass}`));
            this.all = [...this.boxes];

            if (this.boxes.length) {
                if (this.disabled()) {
                    this.resetStyle();
                } else {
                    this.boxes.forEach(box => this.applyStyle(box, true));
                }
            }

            if (!this.disabled()) {
                this.addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);
                this.addEvent(window, 'resize', this.scrollHandler);
                this.interval = setInterval(this.scrollCallback, 50);
            }

            if (this.config.live) {
                const observer = new MutationObserver(records => {
                    records.forEach(record => {
                        Array.from(record.addedNodes).forEach(node => this.doSync(node));
                    });
                });

                observer.observe(document.body, { childList: true, subtree: true });
            }
        }

        stop() {
            this.stopped = true;
            this.removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);
            this.removeEvent(window, 'resize', this.scrollHandler);
            if (this.interval) clearInterval(this.interval);
        }

        sync() {
            if (!window.MutationObserver) this.doSync(this.element);
        }

        doSync(element) {
            if (typeof element === 'undefined' || element === null) element = this.element;

            if (element.nodeType === 1) {
                const newBoxes = Array.from(element.querySelectorAll(`.${this.config.boxClass}`));
                newBoxes.forEach(box => {
                    if (!this.all.includes(box)) {
                        this.boxes.push(box);
                        this.all.push(box);
                        if (!this.stopped && !this.disabled()) {
                            this.applyStyle(box, true);
                        }
                        this.scrolled = true;
                    }
                });
            }
        }

        show(box) {
            this.applyStyle(box);
            box.className = `${box.className} ${this.config.animateClass}`;

            if (this.config.callback) {
                this.config.callback(box);
            }

            this.dispatchEvent(box, this.wowEvent);

            if (this.config.resetAnimation) {
                this.addEvent(box, 'animationend', this.resetAnimation);
                this.addEvent(box, 'oanimationend', this.resetAnimation);
                this.addEvent(box, 'webkitAnimationEnd', this.resetAnimation);
                this.addEvent(box, 'MSAnimationEnd', this.resetAnimation);
            }

            return box;
        }

        applyStyle(box, hidden) {
            const duration = box.getAttribute('data-wow-duration');
            const delay = box.getAttribute('data-wow-delay');
            const iteration = box.getAttribute('data-wow-iteration');

            this.animate(() => {
                this.customStyle(box, hidden, duration, delay, iteration);
            });
        }

        resetStyle() {
            this.boxes.forEach(box => box.style.visibility = 'visible');
        }

        resetAnimation(event) {
            if (event.type.toLowerCase().includes('animationend')) {
                const target = event.target || event.srcElement;
                target.className = target.className.replace(this.config.animateClass, '').trim();
            }
        }

        customStyle(box, hidden, duration, delay, iteration) {
            if (hidden) this.cacheAnimationName(box);

            box.style.visibility = hidden ? 'hidden' : 'visible';

            if (duration) this.vendorSet(box.style, { animationDuration: duration });
            if (delay) this.vendorSet(box.style, { animationDelay: delay });
            if (iteration) this.vendorSet(box.style, { animationIterationCount: iteration });

            this.vendorSet(box.style, { animationName: hidden ? 'none' : this.cachedAnimationName(box) });
        }

        vendorSet(elementStyle, properties) {
            for (const [property, value] of Object.entries(properties)) {
                elementStyle[property] = value;
                this.vendors.forEach(vendor => {
                    elementStyle[`${vendor}${property.charAt(0).toUpperCase()}${property.slice(1)}`] = value;
                });
            }
        }

        vendorCSS(element, property) {
            const style = getComputedStyle(element);
            return style.getPropertyValue(property) || style[property];
        }

        animationName(box) {
            try {
                return this.vendorCSS(box, 'animation-name') || getComputedStyle(box).getPropertyValue('animation-name');
            } catch {
                return '';
            }
        }

        cacheAnimationName(box) {
            this.animationNameCache.set(box, this.animationName(box));
        }

        cachedAnimationName(box) {
            return this.animationNameCache.get(box);
        }

        scrollHandler() {
            this.scrolled = true;
        }

        scrollCallback() {
            if (this.scrolled) {
                this.scrolled = false;
                this.boxes = this.boxes.filter(box => {
                    if (this.isVisible(box)) {
                        this.show(box);
                        return false;
                    }
                    return true;
                });

                if (!this.boxes.length && !this.config.live) {
                    this.stop();
                }
            }
        }

        offsetTop(element) {
            let offsetTop = element.offsetTop;
            while (element = element.offsetParent) {
                offsetTop += element.offsetTop;
            }
            return offsetTop;
        }

        isVisible(box) {
            const offset = box.getAttribute('data-wow-offset') || this.config.offset;
            const pageYOffset = window.pageYOffset;
            const viewBottom = pageYOffset + Math.min(this.element.clientHeight, window.innerHeight) - offset;
            const boxTop = this.offsetTop(box);
            const boxBottom = boxTop + box.clientHeight;

            return viewBottom >= boxTop && boxBottom >= pageYOffset;
        }

        disabled() {
            return !this.config.mobile && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        createEvent(name) {
            const event = new Event(name);
            return event;
        }

        dispatchEvent(element, event) {
            element.dispatchEvent(event);
        }

        addEvent(element, type, listener) {
            element.addEventListener(type, listener, false);
        }

        removeEvent(element, type, listener) {
            element.removeEventListener(type, listener, false);
        }
    }

    exports.default = WOW;
    module.exports = exports.default;
});
